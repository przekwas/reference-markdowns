# Authentication and Authorization

The purpose of this lecture series is to teach y'all the _basic_ workflow of how to secure certain endpoints on your Express servers. Don't stress about all the nitty-gritty code as more than likely your first job, each project you code, and so on will be using different concepts and implementations. The big picture you want to understand here is the basics of how the process flows together. And keep in mind, this is one of **many** different ways to implement even a simple `Login` request and a `Protected` endpoint request. Here's what you want to know from a terminology standpoint:

-   Authentication confirms that users are who they say they are.
-   Authorization gives those users permission to access a resource.

&nbsp;

## Basic Diagram

![Auth Diagram](https://i.imgur.com/e6V1fV0.png)

&nbsp;

## Stateful vs Stateless

Stateful authentication workflows, sometimes referred to as _sessions_, are commonly used in applications that do not require too much scalability. While we won't be coding sessions, they're important to at least know. And our labs can easily convert to use them if needed. Basically our servers would make a session ID that we'd store in the database, and we'd give the ID to our React applications when someone "logs in" or comes back to our application and they're still considered "logged in." Everytime a request is made, the session ID is checked on by the database, and then allows a request to continue.

-   Pros
    -   Easy to revoke/ban sessions
    -   Easy to stay "in sync" with data
-   Cons
    -   Increased server load with queries
    -   Harder to scale
    -   Difficult to integrate for 3rd Party Apps

&nbsp;

Stateless authentication workflows aim to solve some of the cons of stateful workflow. This is what we'll be implementing in this lecture and walkthrough series. In this workflow, our server will generate some kind of encoded, not encrypted, "token" that represents a user has successfully logged in at some point. It will not be stored in the database, and instead simply sent off to our React applications to store somewhere. Then, at a later time, the token is sent back to our server who can quickly validate if it's genuine or not, and let the request continue quickly and easily.

-   Pros
    -   Low server load with no query
    -   Easy to scale
    -   Easy to integrate for 3rd Party Apps
-   Cons
    -   Cannot revoke/ban at anytime
    -   More technical complexity

&nbsp;

## HTTP Authentication

HTTP provides a general framework for access control and authentication. Kind of a like heavily suggested set of guidelines to follow, but not as strict as a rulebook. In particular, we'll be using the `Bearer Authentication` scheme, sometimes called `Token Authentication`. The name "Bearer authentication" can be understood as "give access to the bearer of this token." The bearer token is a cryptic string (a JSON Web Token in our case), usually generated by the server in response to a login request. The client must send this token in the `Authorization` header when making requests to protected resources:

```js
{ "Authorization": "Bearer TOKEN" }
```

The server will check the `req.headers` for the key of `Authorization`, confirm its value contains the string value `Bearer` and then we can grab the value after `Bearer` and safely assume its our token. The server then validates the authenticity of that token, and then allows the protected resource to be retreived.

&nbsp;

## JSON Web Tokens

```bash
npm i jsonwebtoken @types/jsonwebtoken
```

_warning technical term vomit ahead ..._ JSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the HMAC algorithm) or a public/private key pair using RSA or ECDSA. Although JWTs can be encrypted to also provide secrecy between parties, we will focus on signed tokens. Signed tokens can verify the integrity of the claims contained within it, while encrypted tokens hide those claims from other parties. When tokens are signed using public/private key pairs, the signature also certifies that only the party holding the private key is the one that signed it.

Whew .. so what does that mean to us? The JWT represents a user's successful login attempt, and as long as its not expired, we can treat that user as "logged in" for its duration. The JWT comes in three parts:

-   the header, which describes the token
-   the payload, which contains the JWTâ€™s claims
-   the footer, which is a signature hash that can be used to verify the integrity of the token

Here's a page to see what they look like: [https://www.jsonwebtoken.io/](https://www.jsonwebtoken.io/)

**REMEMBER** that JWT's are _encoded_ **not** _encrypted_ !

&nbsp;

## Environment Variables

(Note this is a copy/paste from the Third Party APIs lecture!)

Environment Variables are a way for us as developers to provide different variables for what "environment" we are running our application in - meaning we can have testing values in the development phase, and real-world production values when we deploy our apps to cloud services! They also allow us to hide secret values, such as API keys, away from GitHub but still let our code run. It's as simple as creating a `.env` file in the root of your project, adding a `VARIABLE_NAME=value` in that file, and using the `dotenv` module where you need those values.

The values are loaded during the applications initialization and are read at runtime with `process.env` with an additional suffix for your chosen variable name.

In your terminal:

```bash
npm i dotenv
```

In `.env` at the _root_ of the project

```
MY_HIDDEN_KEY=this-is-cool
```

**DO NOT FORGET TO ADD TO .gitignore**:

```
.env
```

And finally in a config folder/file or directly in the file you want to read this value:

```js
import * as dotenv from 'dotenv';
dotenv.config();

// gives us 'this-is-cool'
process.env.MY_HIDDEN_KEY;
```

&nbsp;

## Bcrypt

```bash
npm i bcrypt @types/bcrypt
```

This is a _fantastic_ and _standard_ password-hashing function based on the [Blowfish cipher](<https://en.wikipedia.org/wiki/Blowfish_(cipher)>) which is where the `b` comes from in the name, and `crypt` for the name of the hashing function used by the UNIX password system. Put them together and we get `bcrypt`! Here's some key terms we need to know:

-   Salt: is random data that is used as an additional input to a one-way function that hashes data, a password or passphrase. Salts are used to safeguard passwords in storage.
-   Hash: any function that can be used to map data of arbitrary size to fixed-size values.

An example of a hash table:

![Hash Table](https://modeling-languages.com/wp-content/uploads/2018/10/hash.png)

An example of a hash + salt worfklow:

![Salt and Hash Workflow](https://blogs.quickheal.com/wp-content/uploads/2012/06/password-hash-salt.png)

&nbsp;

## Passport

```bash
npm i passport @types/passport
```

Passport is authentication middleware for Node.js. It's flexible, lightweight, and very modular. It also can easily be added as yet another middleware for our Express applications, too! The [Documentation](http://www.passportjs.org/docs/) for Passport, as well as the [Strategies Search Page](http://www.passportjs.org/packages/) will your best friends in exploring what it can do. Each "Strategy" is basically an auth workflow encapsulated as a function and middleware for Passport.

For something as simple as what we're going to be coding? We actually don't need Passport at all. We can run our own code on the `req.headers` for example to find what we need and authorize it as we see fit. So why use Passport, you may be wondering? It does streamline and automate some of the logic for us, and allows us to abstract our auth code into separate files and functions.

Where it _really_ shines is when you want to add third party logins to your applications. Things like Google, Twitter, or Facebook logins are made much easier with Passport. So with all things development-wise, it's a trade off (my favorite concept)!

&nbsp;

## Passport Strategies

```bash
npm i passport-local @types/passport-local
```

-   `PassportLocal` is a strategy for authenticating with a username (or email) and password. It means _we_ will code our own login form, an endpoint that takes the credentials, verifies them against our database, and then tells us if we are good to go (status 200) or something didn't line up (status 401).

```bash
npm i passport-jwt @types/passport-jwt
```

-   `PassportJWT` is a strategy for authenticating with a JSON Web Token (JWT). This nifty strategy can be coded to find our JWT on our request in **many** different ways! It will also verify that the JWT is not expired, and that it matches our hidden signature. It is intended to be used to secure RESTful endpoints without sessions. This is called "stateless" and is what JWT is meant to do. However, with that choice comes .. you guessed it .. trade offs!

&nbsp;

### A Short note about Passport ...

These functions _must_ be configured onto Passport for it to work, even if we aren't using "sessions":

```typescript
// responsible for making req.session
// we don't really use this, but it needs to be written
passport.serializeUser((user: Payload, done) => {
	done(null, user);
});

// responsible for making req.user
// we can co-opt this to do repeated tasks if needed
// and it's also required to be written ;)
passport.deserializeUser((user: Payload, done) => {
	done(null, user);
});
```

&nbsp;

## Custom Passport Callback

```typescript
// example path to file:
// src/server/middlewares/auth.mw.ts

import { authenticate } from 'passport';
import { Request, Response, NextFunction } from 'express';

// a custom Request Handling function, aka an Express Middleware!
// it uses the `passport.authenticate('jwt') and adds a custom callback
// that allows us to custom error handle our responses
export function tokenCheck(req: Request, res: Response, next: NextFunction) {
	authenticate('jwt', (err, user, info) => {
		if (err) {
			return next(err);
		}

		if (info) {
			return res.status(401).json({ message: info.message });
		}

		if (!user) {
			return res.status(401).json({ message: 'redirect to login' });
		}

		req.user = user;
		next();
	})(req, res, next); // <- IIFE
}
```

&nbsp;

## Utility Code Examples

```typescript
// example path to file:
// src/server/utils/passwords.ts

import * as bcrypt from 'bcrypt';

// takes a user's plaintext password
export function generateHash(password: string) {
	// generates a salt and number of rounds
	const salt = bcrypt.genSaltSync(12);
	// takes plaintext password, salt, and rounds
	const hash = bcrypt.hashSync(password, salt);
	// returns a salt+hash version to store in database!
	return hash;
}

// takes a user's plaintext password during login
// compares it to the salt+hash stored in database
// and returns a boolean whether they match
export function compareHash(password: string, hashed: string) {
	return bcrypt.compareSync(password, hashed);
}
```

&nbsp;

```typescript
// example path to file:
// src/server/types/index.ts

// import other types we use here
import { Request } from 'express';
import { UsersTable } from '../db/models';

// this type references any endpoint behind passport middleware
// tells the endpoint what req.user has on it
export interface ReqUser extends Request {
	user?: Payload;
}

// this type references our JWT payload and all UserTable properties
// used in the passport-jwt strategy and token signing
export interface Payload extends UsersTable {
	userid?: number;
	role?: number;
}
```